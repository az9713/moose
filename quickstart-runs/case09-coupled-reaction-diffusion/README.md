# Case 09: Coupled Two-Variable Reaction-Diffusion System

## Overview

This case introduces the concept of **coupled multi-physics** — solving for two
unknowns simultaneously where each one appears in the equation of the other. This is
the foundation of nearly all real MOOSE applications: heat transfer coupled to thermal
stress, fluid flow coupled to species transport, neutron flux coupled to temperature.

The specific problem is a **reaction-diffusion system** with two chemical species, `u`
and `v`. Each diffuses independently through a unit-square domain. They also interact:
`v` acts as a source that generates `u`, while `u` acts as a sink that depletes `v`.
The coupling creates interesting dynamics — `u` diffuses inward from the left boundary,
`v` is generated by `u`, but `v` is also consumed by `u`. Over time the system
approaches a coupled steady state.

Three important MOOSE features are demonstrated here:

1. **Multiple variables**: Two scalar unknowns (`u` and `v`) solved simultaneously in
   a single coupled linear system. The Jacobian has four blocks: du/du, du/dv, dv/du, dv/dv.

2. **CoupledForce kernel**: A kernel that adds a term proportional to *another* variable
   to the equation for the current variable. This is the MOOSE primitive for reaction
   coupling.

3. **IterationAdaptiveDT**: An adaptive time stepper that automatically grows the time
   step when Newton converges quickly and shrinks it when convergence is difficult. This
   is essential for efficient long transient simulations.

---

## The Physics

### Physical Problem in Plain English

Picture a unit-square reaction chamber. Two chemical species, `u` and `v`, are
dissolved in a stationary medium. Both species diffuse (spread out by molecular motion).
They also react with each other according to simple rate laws:

- `u` is produced at a rate proportional to the local concentration of `v`. Wherever
  `v` is present, it generates `u`.
- `v` is consumed at a rate proportional to the local concentration of `u`. Wherever
  `u` is present, it destroys `v`.

Additionally, `u` is driven into the domain from the left wall (Dirichlet BC, `u=1`)
and leaves through the right wall (`u=0`). All four walls prevent `v` from leaving
(Dirichlet `v=0` everywhere, which is a zero-value rather than zero-flux condition).

Starting from zero concentration everywhere, `u` diffuses in from the left and creates
`v`. The `v` field builds up, reinforcing `u` production. Over time the system reaches
a quasi-steady coupled state where diffusion, production, and consumption balance.

### Governing Equations

The two-equation system is:

```
du/dt = Du * Laplacian(u) + v        in [0,1] x [0,1]
dv/dt = Dv * Laplacian(v) - u        in [0,1] x [0,1]
```

In long form with x and y derivatives explicit:

```
du/dt = Du * (d²u/dx² + d²u/dy²) + v
dv/dt = Dv * (d²v/dx² + d²v/dy²) - u
```

Symbol definitions:

- `u(x,y,t)` — concentration of species U [mol/m³ or dimensionless]
- `v(x,y,t)` — concentration of species V [mol/m³ or dimensionless]
- `t` — time [s]
- `Du = 1.0` — diffusivity of species U [m²/s or dimensionless]. U spreads faster.
- `Dv = 0.5` — diffusivity of species V [m²/s or dimensionless]. V spreads slower.
- `Laplacian(u)` — the sum of second spatial derivatives: `d²u/dx² + d²u/dy²`
- `+v` in the u equation — coupling term: `v` is a source for `u`. Positive coupling.
- `-u` in the v equation — coupling term: `u` is a sink for `v`. Negative coupling.

The different diffusivities (Du=1, Dv=0.5) mean `u` spreads twice as fast as `v`.
This asymmetry produces an interesting spatial pattern: `u` has a broader distribution
while `v` is more concentrated near the left boundary where `u` is largest.

### The Coupling: Source and Sink

The `+v` and `-u` terms couple the two equations. This is a classic predator-prey or
activator-inhibitor pattern:

- `u` is the **activator**: it diffuses faster and is driven by the left boundary.
- `v` is the **inhibitor**: it is generated by `u` but also destroys itself (through
  the `-u` term which acts as a sink).

The `CoupledForce` kernel in MOOSE adds a term `coef * v_variable` to the equation
for a given variable. Using a negative coefficient (`coef = -1.0`) makes the coupled
species a sink term rather than a source.

### Why Coupled Systems Are Harder

In a single-variable problem, the Jacobian is a single N×N block (N = number of DOFs
for that variable). The linear system at each Newton step is N×N.

With two coupled variables u and v (both with N DOFs), the Jacobian is 2N×2N:

```
J = | dR_u/du   dR_u/dv |
    | dR_v/du   dR_v/dv |
```

The off-diagonal blocks `dR_u/dv` and `dR_v/du` represent how changes in one variable
affect the residuals of the other — these arise from the CoupledForce terms. Capturing
these off-diagonal blocks correctly is essential for fast Newton convergence in tightly
coupled systems.

MOOSE automatically assembles the full coupled Jacobian when using `MatDiffusion` and
`CoupledForce` with the PJFNK solver. The off-diagonal contributions are computed via
finite differences of the residual (that is what JFNK means), so no hand-coding of
cross-variable derivatives is needed.

### Boundary Conditions

For `u`:
```
u = 1    on x=0 (left wall) — drives the system
u = 0    on x=1 (right wall) — downstream outflow
```

The top and bottom walls have no explicit BC for `u`, giving natural zero-flux Neumann.
This means `u` cannot leave through the top or bottom — it diffuses sideways and must
exit through the right boundary.

For `v`:
```
v = 0    on all four walls
```

All walls hold `v` at zero. This is somewhat artificial but provides a clean, well-posed
boundary value problem. It means `v` is generated in the interior by `u` and absorbed
at all walls.

### Initial Conditions

Both `u` and `v` start at zero everywhere (the default when no `[ICs]` block is given):

```
u(x, y, 0) = 0
v(x, y, 0) = 0
```

The system is then driven by the boundary condition `u = 1` on the left wall. As time
advances, `u` diffuses inward, creating `v`, which feeds back into `u`.

### ASCII Domain Diagram

```
y=1   u: zero-flux (Neumann)    v: v=0 (Dirichlet)
      +------------------------------------------+
      |                                          |
      |   du/dt = Du*Lap(u) + v                  |
      |   dv/dt = Dv*Lap(v) - u                  |
      |                                          |
u=1   |   Du = 1.0, Dv = 0.5                     | u=0
v=0   |                                          | v=0
(Dir) |   At steady state:                       | (Dir)
      |   u profile: ~1 near left, ~0 right      |
      |   v profile: generated by u, absorbed    |
      |   at walls, maximum somewhere in middle  |
      |                                          |
      +------------------------------------------+
y=0   u: zero-flux (Neumann)    v: v=0 (Dirichlet)
      x=0                                     x=1

Mesh: 30 x 30 uniform quadrilateral elements
      900 elements, 961 nodes
      2 x 961 = 1922 total DOFs
```

---

## Adaptive Time Stepping: IterationAdaptiveDT

### The Motivation

Fixed time stepping (as in Case 08) is simple but wasteful. When the solution changes
rapidly (early in a transient, or during a fast event), small time steps are needed for
accuracy. When the solution changes slowly (approaching steady state), large time steps
can be taken without loss of accuracy.

`IterationAdaptiveDT` automatically adjusts `dt` based on how hard the nonlinear
solver worked in the previous step. The logic is:

- If Newton converged in **few** iterations (easy problem), the time step was probably
  conservative — grow dt for the next step (less work needed).
- If Newton converged in **many** iterations (hard problem), the time step was too
  aggressive — shrink dt for the next step (more stability).
- If Newton **failed to converge**, cut dt by the cutback factor and retry.

This mirrors the strategy an experienced engineer would use when running a simulation
by hand.

### Parameters in This Case

```
[TimeStepper]
  type             = IterationAdaptiveDT
  dt               = 0.01
  growth_factor    = 2.0
  cutback_factor   = 0.5
  optimal_iterations = 8
[]
```

- `dt = 0.01` — initial time step size (also serves as the starting dt).
- `growth_factor = 2.0` — if Newton used fewer than `optimal_iterations`, multiply
  dt by 2.0 for the next step. This doubles the time step when things are going well.
- `cutback_factor = 0.5` — if Newton converged with more than `optimal_iterations`
  iterations, or if it failed, multiply dt by 0.5. This halves the step to try again.
- `optimal_iterations = 8` — the target number of Newton iterations. If actual
  iterations < 8, grow dt. If actual iterations > 8 (up to `nl_max_its = 15`), shrink dt.

The growth and cutback factors are asymmetric (2.0 vs. 0.5) by design: it is safe to
grow dt aggressively when things are easy, but you must cut back carefully when things
are hard to avoid repeatedly wasting Newton iterations.

### Typical Behavior

At the start of this problem, the solution changes rapidly as `u` diffuses in from the
left wall and `v` starts building up. Newton requires many iterations per step. The
time stepper keeps dt small (or even cuts it back if needed).

As the system approaches quasi-steady state (roughly t > 0.5), changes become slower.
Newton converges in fewer iterations. The time stepper grows dt, eventually reaching
dt = `0.01 * 2^k` for some number of successful doublings `k`. For `end_time = 2.0`,
this means the last few time steps may have dt ≫ 0.01, completing the simulation
much faster than if `dt = 0.01` were used throughout.

---

## Input File Walkthrough

The input file is `case09_coupled_system.i`.

### Block: `[Mesh]`

```
[Mesh]
  type = GeneratedMesh
  dim  = 2
  nx   = 30
  ny   = 30
[]
```

- `type = GeneratedMesh` — structured rectangular unit square mesh.
- `dim = 2` — two-dimensional problem.
- `nx = 30, ny = 30` — 30 elements in each direction. 900 elements, 961 nodes.
  With default domain [0,1], element size is 1/30 ≈ 0.0333.

Why 30x30 instead of 20x20 (as used in Cases 01-07)? The coupled system produces
solution features that are somewhat more localized than simple diffusion, particularly
near the left boundary where `u` transitions from 1 to lower values. Finer resolution
captures this transition more accurately.

Total DOFs: 2 variables × 961 nodes = 1,922. The linear system at each Newton
iteration is 1,922 × 1,922 (sparse, with bandwidth determined by the mesh connectivity
and the variable coupling).

### Block: `[Variables]`

```
[Variables]
  [u]
  []
  [v]
  []
[]
```

Two unknowns are declared simultaneously. Each uses the default (first-order Lagrange,
zero initial condition). The order of declaration matters: MOOSE internally assigns
equation numbers in this order. The global DOF vector has `u` DOFs first, then `v` DOFs.

Both variables are solved simultaneously in a coupled nonlinear system. MOOSE does not
split them into separate solves — it assembles a 1,922×1,922 Jacobian that includes
all cross-coupling terms, then solves the full coupled system.

This "monolithic" approach (all variables in one system) is more expensive per step
than operator-splitting (solve u first, then v), but it is more accurate and stable,
especially for tightly coupled physics where splitting introduces errors.

### Block: `[Kernels]`

```
[Kernels]
  # --- Equation for u ---
  [u_time]
    type     = TimeDerivative
    variable = u
  []
  [u_diff]
    type     = MatDiffusion
    variable = u
    diffusivity = Du
  []
  [u_source]
    type     = CoupledForce
    variable = u
    v        = v
  []

  # --- Equation for v ---
  [v_time]
    type     = TimeDerivative
    variable = v
  []
  [v_diff]
    type     = MatDiffusion
    variable = v
    diffusivity = Dv
  []
  [v_sink]
    type        = CoupledForce
    variable    = v
    v           = u
    coef        = -1.0
  []
[]
```

Six kernels implement the two-equation PDE system.

**Kernels for the `u` equation** (`du/dt = Du*Lap(u) + v`):

- `[u_time]`: `type = TimeDerivative` — implements `du/dt` in weak form:
  ```
  integral( phi_i * du/dt ) dV
  ```
  Standard time derivative kernel, same as Case 08. Essential for the transient problem.

- `[u_diff]`: `type = MatDiffusion, variable = u, diffusivity = Du` — diffusion of `u`
  with diffusivity `Du` from the materials block. Implements:
  ```
  integral( Du * grad(phi_i) . grad(u) ) dV
  ```
  This is the `Du * Laplacian(u)` term in strong form.

- `[u_source]`: `type = CoupledForce, variable = u, v = v` — the coupling source term.
  Implements:
  ```
  -integral( phi_i * v ) dV
  ```
  (negative sign because residual = left_side - right_side, or equivalently: move
  the source to the left side as `R_u = du/dt - Du*Lap(u) - v`, and in weak form
  the kernel adds `-integral(phi_i * v) dV` to `R_u`).

  The parameter `v = v` uses a slightly confusing but standard MOOSE naming: the
  parameter name is `v` (the CoupledForce parameter that expects the coupling variable)
  and its value is `v` (the name of the MOOSE variable declared in `[Variables]`).

  The default `coef = 1.0` means the coupling is a source (`+v` in the equation).

**Kernels for the `v` equation** (`dv/dt = Dv*Lap(v) - u`):

- `[v_time]`: `type = TimeDerivative, variable = v` — `dv/dt` term. Same as `u_time`
  but for the `v` variable.

- `[v_diff]`: `type = MatDiffusion, variable = v, diffusivity = Dv` — diffusion of `v`
  with the smaller diffusivity `Dv = 0.5`. Same kernel as `u_diff`, different variable
  and material property. This is the power of MOOSE's object-oriented design: one kernel
  type handles diffusion for any variable.

- `[v_sink]`: `type = CoupledForce, variable = v, v = u, coef = -1.0` — the coupling
  sink term. Note the parameter assignments:
  - `variable = v` — this kernel modifies the residual for the MOOSE variable `v`
  - `v = u` — the "coupling variable" (the CoupledForce parameter named `v`) is set
    to the MOOSE variable `u`. So `u` enters the residual for `v`.
  - `coef = -1.0` — the negative sign makes this a sink. The kernel adds:
    ```
    +integral( coef * phi_i * u ) dV = -integral( phi_i * u ) dV
    ```
    which in residual form represents the `-u` term in `dv/dt = Dv*Lap(v) - u`.

### The CoupledForce Kernel in Detail

`CoupledForce` is one of MOOSE's most versatile building-block kernels. Its weak form
contribution to the residual for variable `w` is:

```
R_i += -integral( phi_i * coef * coupled_var ) dV
```

(The sign: MOOSE residuals are written as R = 0, so adding `-integral(phi_i * coef * v)`
means the strong-form equation has `+coef * v` on the right-hand side.)

The off-diagonal Jacobian contribution (dR_w/d(coupled_var)) is:

```
J_ij = -integral( phi_i * coef * phi_j ) dV
```

This is the "mass matrix" scaled by `coef`. MOOSE automatically assembles these
off-diagonal blocks when JFNK or Newton is used with coupled variables.

| Parameter | Role |
|-----------|------|
| `variable` | The variable whose residual is modified (the "receiving" equation) |
| `v` | The coupled variable that provides the forcing (the "donor" variable) |
| `coef` | Multiplication factor. Default 1.0 (source). Use -1.0 for a sink. |

### Block: `[BCs]`

```
[BCs]
  [u_left]
    type     = DirichletBC
    variable = u
    boundary = left
    value    = 1.0
  []
  [u_right]
    type     = DirichletBC
    variable = u
    boundary = right
    value    = 0.0
  []
  [v_walls]
    type     = DirichletBC
    variable = v
    boundary = 'left right top bottom'
    value    = 0.0
  []
[]
```

Three BC objects are defined:

- `[u_left]`: Pins `u=1` at the left wall. This is the "driver" of the entire system.
  Without this BC, with zero ICs and no source term, both u and v would remain zero.
  The `u=1` BC is the energy input that drives the coupled dynamics.

- `[u_right]`: Pins `u=0` at the right wall. This models the right boundary as a
  perfect absorber for species U. Combined with `u=1` at left and diffusion, this
  creates a gradient in `u` from 1 to 0 across the domain — the quasi-steady profile.

- **Top and bottom for u**: No explicit BC entry. Natural zero-flux Neumann. U cannot
  leave through the top or bottom walls.

- `[v_walls]`: Pins `v=0` at all four walls. This single BC object covers all four
  boundaries for `v` simultaneously. All walls absorb `v`: whatever `v` is generated
  by the coupling with `u` in the interior, it cannot build up at the boundaries.

Note that BCs for `u` and `v` are completely independent — you set them separately for
each variable and they can differ in type, value, and location.

### Block: `[Materials]`

```
[Materials]
  [diffusivities]
    type        = GenericConstantMaterial
    prop_names  = 'Du  Dv'
    prop_values = '1.0 0.5'
  []
[]
```

A single material object defines both diffusivity properties at once:

- `type = GenericConstantMaterial` — declares one or more scalar constant properties.
- `prop_names = 'Du Dv'` — two property names in a space-separated list.
- `prop_values = '1.0 0.5'` — corresponding constant values. `Du=1.0` for `u` (faster
  diffusion), `Dv=0.5` for `v` (slower diffusion).

This is more concise than defining two separate material objects. The properties are
available to any kernel or material in the domain.

### Block: `[Postprocessors]`

```
[Postprocessors]
  [avg_u]
    type     = ElementAverageValue
    variable = u
  []
  [avg_v]
    type     = ElementAverageValue
    variable = v
  []
[]
```

Two postprocessors track the domain-averaged values of each variable:

- `type = ElementAverageValue` — computes `integral(variable dV) / total_volume`.
  For a unit square, this equals the integral.
- `[avg_u]` and `[avg_v]` track the spatial average of `u` and `v` over time.

Monitoring both averages in the CSV file reveals the coupled dynamics:
- `avg_u` grows as `u` diffuses in from the left, then levels off as steady state
  is approached.
- `avg_v` lags behind `avg_u` (it needs `u` to be present before it can be generated),
  grows more slowly (Dv < Du), and levels off at a lower value because it is being
  consumed.

The two curves in the CSV, when plotted, show the interplay between the two species.

### Block: `[Executioner]`

```
[Executioner]
  type = Transient
  solve_type = 'PJFNK'
  petsc_options_iname = '-pc_type -pc_hypre_type'
  petsc_options_value = 'hypre    boomeramg'

  dt       = 0.01
  end_time = 2.0

  nl_rel_tol = 1e-8
  nl_abs_tol = 1e-10
  nl_max_its = 15

  [TimeStepper]
    type = IterationAdaptiveDT
    dt = 0.01
    growth_factor = 2.0
    cutback_factor = 0.5
    optimal_iterations = 8
  []
[]
```

- `type = Transient` — time-marching simulation.

- `solve_type = 'PJFNK'` — Preconditioned Jacobian-Free Newton-Krylov. The coupled
  system has an implicit coupling Jacobian that JFNK approximates via residual finite
  differences. For this problem with moderate coupling, PJFNK converges well.

- `petsc_options_iname / petsc_options_value` — uses HYPRE BoomerAMG, the same AMG
  preconditioner as Case 07. BoomerAMG is effective for the 2x2 block system arising
  from the two coupled diffusion equations.

- `dt = 0.01` — the initial time step size. This also appears inside `[TimeStepper]`
  as the starting dt; the value in the `[Executioner]` block is used only as a fallback.

- `end_time = 2.0` — run for 2 seconds. With adaptive stepping, the number of time
  steps is not fixed — it depends on how quickly the time stepper can grow dt.

- `nl_rel_tol = 1e-8` — tight relative tolerance for the nonlinear solver. This is
  tighter than Case 08 because the coupled system requires accurate resolution of
  both variables to get the interactions right.

- `nl_abs_tol = 1e-10` — absolute tolerance floor.

- `nl_max_its = 15` — maximum Newton iterations per step. If Newton has not converged
  after 15 iterations, the `IterationAdaptiveDT` will cut back dt by `cutback_factor`
  and retry. This prevents wasted computation on hopeless time steps.

**The `[TimeStepper]` sub-block:**

```
[TimeStepper]
  type             = IterationAdaptiveDT
  dt               = 0.01
  growth_factor    = 2.0
  cutback_factor   = 0.5
  optimal_iterations = 8
[]
```

This is a sub-block inside `[Executioner]`. MOOSE executioners can contain sub-blocks
for time steppers, quadrature settings, and predictor configurations.

- `type = IterationAdaptiveDT` — selects the iteration-count-based adaptive stepper.
- `dt = 0.01` — the initial time step. The stepper begins here and adjusts from this
  starting point.
- `growth_factor = 2.0` — when the previous Newton solve used fewer than
  `optimal_iterations = 8` iterations, multiply dt by 2 for the next step.
- `cutback_factor = 0.5` — when the previous Newton solve used more than 8 iterations
  (or failed to converge within `nl_max_its = 15`), multiply dt by 0.5 and retry.
- `optimal_iterations = 8` — the target Newton iteration count. This is set to 8 out
  of a maximum of 15, leaving a safety margin. If actual iterations are below 8,
  the problem is considered "easy" and dt is grown. If above 8, it is "hard" and dt
  is reduced.

### Block: `[Outputs]`

```
[Outputs]
  exodus = true
  csv    = true
[]
```

- `exodus = true` — writes both `u` and `v` fields to the Exodus file at every
  output time step. The Exodus file has two named variable arrays: `u` and `v`.
- `csv = true` — writes `avg_u` and `avg_v` at every time step to the CSV file.

Note: with adaptive time stepping, the number of rows in the CSV file is not
predetermined. The stepper may take 20 steps or 200, depending on how the Newton
convergence behaves. The CSV file captures all of them.

---

## What Happens When You Run This

### Invocation

```bash
cd quickstart-runs/case09
mpirun -n 1 moose-app-opt -i case09_coupled_system.i
```

### Startup Phase

1. MOOSE parses the input file, creates two variables `u` and `v`, six kernels,
   three BC objects, one material, two postprocessors, and the Executioner.
2. `GeneratedMesh` creates the 30x30 mesh with 1,922 total DOFs.
3. The DofMap interleaves `u` and `v` DOFs in the global vector (or blocks them,
   depending on the solver configuration).
4. The `IterationAdaptiveDT` object is initialized with `dt = 0.01`.
5. Initial conditions are applied: both `u = 0` and `v = 0` everywhere. Then the
   Dirichlet BCs are enforced: `u_left` node set receives `u = 1`, etc.

### Early Time Steps (t = 0 to ~0.1): Fast Dynamics

At t=0, `u=0` everywhere except on the left boundary where `u=1`. This sharp gradient
drives a large initial residual. Newton requires many iterations.

```
Time Step 1, time = 0.01, dt = 0.01
 0 Nonlinear |R| = 5.234e+01
      0 Linear |R| = 8.765e-11
 1 Nonlinear |R| = 3.456e-02
      ...
 8 Nonlinear |R| = 7.890e-09

Converged! (8 iterations — at optimal, dt stays the same)
```

```
Time Step 2, time = 0.02, dt = 0.01
 0 Nonlinear |R| = 2.123e+01
      ...
 5 Nonlinear |R| = 4.567e-09

Converged! (5 iterations — below optimal, dt grows to 0.02)
```

### Middle Time Steps (t = 0.1 to ~0.5): dt Growth

As `u` penetrates the domain and `v` builds up, the solution changes more smoothly.
Newton converges in fewer iterations each step. The time stepper doubles dt repeatedly:

```
dt: 0.01 → 0.02 → 0.04 → 0.08 → 0.16 → ...
```

Each doubling halves the number of time steps needed for the same elapsed time.

### Late Time Steps (t > 0.5): Near Steady State

As both `u` and `v` approach their coupled steady-state distributions, changes per
time step become tiny. Newton converges in 1 to 3 iterations. The time stepper continues
to grow dt, and the simulation completes to `end_time = 2.0` in far fewer steps than
the 200 that would have been needed with fixed `dt = 0.01`.

A typical run might complete in 40-60 adaptive steps instead of 200 fixed steps — a
3-5x reduction in computational cost.

### Console Output Summary

```
Postprocessor Values at t=2.0:
  avg_u = 0.4123
  avg_v = 0.1456
```

(Approximate values — the exact numbers depend on the mesh and solver tolerance.)

The domain average of `u` is around 0.4 (roughly the midpoint of the 0-to-1 gradient
driven by the left and right BCs). The average of `v` is lower because `v` is zero
on all walls and is consumed by `u` throughout the domain.

---

## Output Files

### `case09_coupled_system_out.e`

An Exodus II binary file containing:
- The 30x30 mesh geometry
- Both solution fields `u` and `v` at every time step
- The number of time steps depends on the adaptive stepper: typically 40-80 frames

Open in ParaView and toggle between `u` and `v` variables to see the different
spatial distributions. `u` shows a gradient from left to right (high on left, low on
right). `v` shows a more localized distribution — highest in the region where `u` is
large and diffusing, lower near the `v=0` walls.

### `case09_coupled_system_out.csv`

A time history of both postprocessors:

```
time,avg_u,avg_v
0,0,0
0.01,0.0234,0.00001
0.02,0.0456,...
...
(variable number of rows due to adaptive stepping)
...
2.0,0.4123,0.1456
```

The number of rows varies: with aggressive dt growth, there may be only 40-60 time
steps rather than 200. Both columns grow over time as the species diffuse through the
domain, with `avg_u` leading `avg_v` because `u` has higher diffusivity and is driven
by the boundary condition.

---

## Visualizing the Results in ParaView

1. Open `case09_coupled_system_out.e` in ParaView.
2. Click Apply. In the "Point Arrays" list you should see both `u` and `v` checked.
3. Color by `u`. Animate to see how `u` diffuses inward from the left and approaches
   its steady-state linear profile.
4. Switch to color by `v`. The `v` distribution appears more dome-shaped: zero at
   all walls, maximum somewhere in the interior where `u` is generating it fastest.

To compare `u` and `v` side by side:
- Use Filters > Layout to create two render windows
- In the first window, display `u`; in the second, display `v`
- Step through time in both windows simultaneously

To see the coupled dynamics clearly:
- Filter > Temporal Statistics to compute time-averaged fields
- Or plot avg_u and avg_v from the CSV file on the same axes

To see a line profile through the domain:
- Filters > Data Analysis > Plot Over Line
- Set from (0, 0.5, 0) to (1, 0.5, 0) for a horizontal midline cut
- At steady state, `u` should show a profile curving from u=1 at x=0 to u=0 at x=1,
  modified from a simple linear profile by the `+v` coupling term.
- `v` should show a peak somewhere in the interior.

---

## Understanding the Plots

Running `python visualize_all.py` from the `quickstart-runs/` directory produces the
following three plots saved into this directory.

### `case09_coupled_averages.png`

**What the plot shows.** A line plot with simulation time on the horizontal axis and
average field values on the vertical axis. Two curves are drawn: blue circles for
`avg_u` (spatial average of variable u) and red squares for `avg_v` (spatial average
of variable v).

**Physical quantities.** The coupled system has two fields, u and v. Variable u solves
a transient diffusion problem driven by a source, while v is driven by negative
gradients of u (or by negative u values), making v negative wherever u is positive.

**How to judge correctness.** `avg_u` should rise from zero and asymptote to a
positive steady-state value as the source drives u. `avg_v` should start at zero and
evolve toward a negative steady-state value because v is coupled to u in a way that
makes it respond oppositely. The two curves should move in opposite directions. Both
should be monotone and eventually flatten.

**What would indicate a problem.**
- Both curves staying at zero: neither kernel is driving any evolution — check that
  the kernels and coupling terms are correctly set up.
- `avg_v` positive when it should be negative: the coupling sign is wrong.
- Non-monotone curves (reversals in direction): solver instability or incorrect
  time stepping.

### `case09_u_final.png`

**What the plot shows.** A 2D filled-contour of the u field at the final timestep
(t=2.0), using the viridis colormap.

**Physical quantities.** The color encodes the value of the primary variable u over
the unit square domain.

**How to judge correctness.** The u field should show a smooth spatial gradient
driven by the source term and boundary conditions. The exact shape depends on the
specific coupling and BCs, but it should be a smooth, positive-valued field with the
highest values in the interior (away from zero-Dirichlet walls) and the lowest on the
boundary. There should be no oscillations.

**What would indicate a problem.**
- u = 0 everywhere: the source term is absent or the BCs are pinning everything to zero.
- Oscillatory (checkerboard) pattern: mesh-related instability; the mesh may be too
  coarse for the coupling.

### `case09_v_final.png`

**What the plot shows.** A 2D filled-contour of the v field at the final timestep
(t=2.0), using the viridis colormap.

**Physical quantities.** The color encodes the value of the secondary variable v,
which is driven by coupling to u.

**How to judge correctness.** The v field should have negative values throughout the
domain because v is coupled to u in such a way that wherever u is positive, v is
driven negative. The spatial distribution of v should mirror the shape of u — the
most negative values of v occur where u is largest (near the center), and v approaches
zero near the boundaries (where u also approaches zero due to Dirichlet BCs).

**What would indicate a problem.**
- v = 0 everywhere: the coupling from u to v is missing.
- v positive (same sign as u): the coupling sign is inverted.
- The shape of v bearing no resemblance to u: the coupling is acting on the wrong
  variable or at the wrong location.

---

## Interpreting the Results

### The Coupled Steady State

At `end_time = 2.0`, the system is close to (but may not have fully reached) its
coupled steady state. The steady-state equations are:

```
Du * Laplacian(u) + v = 0    (u_eq)
Dv * Laplacian(v) - u = 0    (v_eq)
```

From the v equation: `v = u / Dv * Laplacian^{-1}(1)` — roughly, `v` is proportional
to `u` divided by `Dv`. With `Du = 1` and `Dv = 0.5`, `v` converges to roughly twice
what it would be if the diffusivities were equal.

### Physical Insight

The `u` profile (at steady state) is not a simple linear gradient from 1 to 0. The
`+v` term in the `u` equation is a source that "puffs up" the `u` profile above what
pure diffusion with BCs would give. This coupling causes `u` to be slightly higher in
the interior than a simple linear interpolation.

Similarly, `v` is generated wherever `u` is present and non-zero, but it is consumed
by the `-u` term in its own equation and absorbed at all walls. The `v` distribution
reaches its maximum somewhere in the interior, forming a dome shape.

### Effect of Different Diffusivities

The asymmetry `Du = 1 > Dv = 0.5` means `u` spreads twice as fast as `v`. At early
times, `u` diffuses through the domain faster than `v` builds up. By t=0.5, `u` has
essentially reached its quasi-steady profile while `v` is still building up more slowly.
This separation of time scales is why the adaptive time stepper can grow dt: the early
rapid changes are in `u`, and once `u` stabilizes, the only slow evolution is `v`.

### Correctness Checks

1. **Boundary conditions**: At any time, the left boundary should have `u ≈ 1.0` and
   all boundaries should have `v ≈ 0.0`. Check in ParaView using a scalar bar.

2. **Positivity**: Both `u` and `v` should be non-negative everywhere (no negative
   concentrations). The problem is set up so that `u` is driven positive from the
   left boundary and `v` is always a positive field generated by the positive `u`.

3. **Monotonic approach to steady state**: `avg_u` and `avg_v` in the CSV should be
   monotonically increasing functions of time, starting at 0 and approaching their
   steady-state values from below.

4. **Time stepper behavior**: Look at the `dt` column in the console output. It should
   start at 0.01 and grow (doubling on successful steps) throughout most of the run.
   Any step where dt shrinks indicates the Newton solver struggled at that point.

---

## Key Concepts Learned

- **Coupled multi-variable systems**: Two unknowns `u` and `v` can be solved
  simultaneously in a single monolithic system. MOOSE assembles the full coupled
  Jacobian automatically.

- **CoupledForce kernel**: Adds a term `coef * v_variable` to the equation for another
  variable. With `coef = 1.0` it is a source; with `coef = -1.0` it is a sink.

- **Off-diagonal Jacobian**: The coupling terms `dR_u/dv` and `dR_v/du` in the
  full system Jacobian. PJFNK computes these automatically via finite differences.

- **Reaction-diffusion system**: A PDE system where reaction (production/consumption)
  terms couple multiple species alongside their individual diffusion.

- **IterationAdaptiveDT**: An adaptive time stepper that grows `dt` when Newton
  converges easily (few iterations) and shrinks it when convergence is hard. Controlled
  by `growth_factor`, `cutback_factor`, and `optimal_iterations`.

- **nl_max_its**: Maximum Newton iterations before declaring failure and cutting back
  dt. Prevents getting stuck on hopeless time steps.

- **Multiple Dirichlet BCs per variable**: A single variable can have different
  Dirichlet values on different boundaries (`u=1` left, `u=0` right for variable `u`).

- **ElementAverageValue postprocessor**: Computes the spatial average of a variable
  over the entire domain at each time step.

- **GenericConstantMaterial with multiple properties**: One `GenericConstantMaterial`
  object can declare multiple material properties simultaneously using space-separated
  lists in `prop_names` and `prop_values`.

- **Sub-blocks in Executioner**: The `[TimeStepper]` block is nested inside
  `[Executioner]`. MOOSE supports sub-blocks for configuring components of larger
  objects (executioners, meshes, etc.).

---

## Experiments to Try

### Experiment 1: Observe Adaptive Time Stepping in Action

Add `print_linear_residuals = true` to the `[Outputs]` block (or look carefully at
the console output) to see how `dt` changes step by step. You can also check the CSV
file: the gaps between `time` values in the CSV reveal the actual `dt` used at each
step. Early steps will be closely spaced (small dt = 0.01), while later steps will
be widely spaced (large dt after many doublings). Count how many total steps were
taken. Then change `growth_factor = 1.0` (no growth) and re-run with a fixed
`dt = 0.01`. Compare the runtimes. The adaptive version should be substantially faster.

Expected outcome: adaptive stepping takes ~40-60 steps; fixed dt takes 200 steps.

### Experiment 2: Flip the Coupling Sign

The current coupling is: `+v` in the `u` equation and `-u` in the `v` equation. This
makes `v` a source for `u` and `u` a sink for `v`. Change both signs: set
`coef = -1.0` in `[u_source]` and `coef = 1.0` in `[v_sink]` (remove the coef line
since 1.0 is default). Now `v` depletes `u` and `u` generates `v`. The coupled
steady-state profile will be qualitatively different, and you may need to check whether
the system still converges — reversed coupling can sometimes make the system ill-posed.

Expected outcome: different spatial profiles for u and v; may require more Newton
iterations to converge.

### Experiment 3: Change the Diffusivity Ratio

Currently `Du = 1.0, Dv = 0.5`. Change to `Du = 0.1, Dv = 1.0` (make v diffuse
faster than u). Now v spreads more broadly and u is more localized near the left
boundary. The average values `avg_u` and `avg_v` in the CSV will converge to different
levels than the original case. Also observe how the time stepper adapts: with v
spreading faster, the early-time dynamics are different.

Expected outcome: `avg_v` grows faster initially and reaches a higher steady-state
value; `avg_u` stays lower and more concentrated near the left.

### Experiment 4: Add a Third Variable

MOOSE naturally handles three or more coupled variables. Add a third species `w` that
is generated by `v` and decays on its own:

```
dw/dt = Dw * Laplacian(w) + v - w
```

In the input file, add `[w]` to `[Variables]`, three kernels for `w` (TimeDerivative,
MatDiffusion, CoupledForce from v, and a -w decay term), and appropriate BCs (w=0
on all walls). Add `Dw = 0.25` to the Materials block. This creates a three-species
cascade: u drives v, v drives w. Observe how the profiles nest: u is widest, then v,
then w (each has less source and more damping).

Expected outcome: three nested spatial profiles, with w being the most localized.

### Experiment 5: Turn Off Adaptive Stepping and Compare

Remove the `[TimeStepper]` sub-block entirely (or change to `type = ConstantDT`).
Set `dt = 0.01` and `end_time = 2.0` for a fixed 200-step run. Compare:
1. Total number of nonlinear iterations (sum over all steps)
2. Wall-clock runtime (if you can time the runs)
3. Final CSV values `avg_u` and `avg_v` (should be the same if both converge correctly)

The fixed-step run should give the same final answer but cost more compute. If the
answers differ slightly, it is because different dt values use different implicit time
integration accuracy. You can reduce `dt` in the fixed-step case to improve accuracy.

Expected outcome: same steady-state answer, but the adaptive version takes 3-5x fewer
time steps.
